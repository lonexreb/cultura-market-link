# AgentOps Flow Forge - Cursor Rules

You are an expert full-stack developer specializing in React/TypeScript frontend with Vite, FastAPI Python backend, and AI workflow orchestration systems.

## Tech Stack & Architecture

### Frontend Stack
- **Framework**: React 18 + TypeScript with Vite
- **UI Library**: Shadcn UI + Radix UI components
- **Styling**: Tailwind CSS with dark theme support
- **State Management**: React Context + TanStack Query for server state
- **Flow Editor**: XYFlow/React for node-based workflows
- **Forms**: React Hook Form + Zod validation
- **Routing**: React Router v6

### Backend Stack
- **Framework**: FastAPI 0.104.1 with Pydantic v2
- **Database**: Neo4j for graph data
- **API Client**: HTTPX for async HTTP requests
- **Validation**: Pydantic models with strict typing
- **Architecture**: Service-oriented with executors pattern

## Code Principles

### General
- Write concise, technical responses with accurate examples
- Use functional, declarative programming - avoid classes where possible
- Prefer iteration and modularization over duplication
- Use descriptive variable names with auxiliary verbs (e.g., `isLoading`, `hasError`)
- Use lowercase with dashes for directories (e.g., `components/api-keys`)
- Favor named exports for components and services

### Error Handling
- Prioritize error handling and edge cases at function start
- Use early returns for error conditions to avoid deep nesting
- Place happy path last in functions for improved readability
- Implement proper error logging and user-friendly messages
- Use custom error types for consistent error handling

## Frontend Guidelines

### React/TypeScript
- Use functional components with TypeScript interfaces
- Use `function` keyword for components, not `const`
- File structure: Exported component, subcomponents, helpers, static content, types
- Use declarative JSX and avoid unnecessary curly braces
- Implement responsive design with Tailwind CSS (mobile-first)
- Place static content and interfaces at file end

### Component Patterns
```typescript
// Node component structure (based on existing ApiNode pattern)
interface NodeProps {
  data: {
    label: string;
    description: string;
    status: 'idle' | 'running' | 'completed' | 'error';
  };
  selected?: boolean;
}

function CustomNode({ data, selected }: NodeProps) {
  const getStatusColor = () => {
    switch (data.status) {
      case 'running': return 'border-slate-400/60 bg-slate-500/10';
      case 'completed': return 'border-green-400/60 bg-green-500/10';
      case 'error': return 'border-red-400/60 bg-red-500/10';
      default: return 'border-slate-400/40 bg-slate-900/20';
    }
  };

  return (
    <div className={`relative min-w-[200px] backdrop-blur-xl border-2 rounded-xl p-4 shadow-lg transition-all duration-300 ${getStatusColor()} ${selected ? 'ring-2 ring-slate-400/50' : ''}`}>
      {/* Component content */}
    </div>
  );
}
```

### Service Layer Pattern
```typescript
// Follow existing apiService pattern
class CustomService {
  private async request(endpoint: string, options: RequestInit = {}) {
    const url = `${API_BASE_URL}${endpoint}`;
    
    const defaultHeaders = {
      'Content-Type': 'application/json',
    };

    const response = await fetch(url, {
      ...options,
      headers: { ...defaultHeaders, ...options.headers },
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`API request failed: ${response.status} ${error}`);
    }

    return response.json();
  }
}

export const customService = new CustomService();
```

### Context Pattern
```typescript
// Follow existing ApiKeysContext pattern
interface CustomContextType {
  data: SomeData;
  isLoading: boolean;
  updateData: (data: SomeData) => Promise<void>;
  loadData: () => Promise<void>;
}

const CustomContext = createContext<CustomContextType | undefined>(undefined);

export const useCustom = () => {
  const context = useContext(CustomContext);
  if (context === undefined) {
    throw new Error('useCustom must be used within a CustomProvider');
  }
  return context;
};
```

### UI Components
- Use Shadcn UI components as base building blocks
- Maintain consistent dark theme styling
- Use Lucide React icons for consistent iconography
- Apply backdrop-blur effects for glassmorphism
- Use gradient backgrounds for visual depth

## Backend Guidelines

### FastAPI Architecture
- Use service-oriented architecture with clear separation
- Follow existing patterns: routes → services → executors
- Use Pydantic models for all request/response validation
- Implement proper dependency injection

### File Structure
```
backend/app/
├── main.py              # FastAPI app initialization
├── config.py            # Pydantic settings
├── models.py            # All Pydantic models
├── routes/              # API route handlers
│   ├── __init__.py
│   └── feature_routes.py
├── services/            # Business logic services
│   ├── __init__.py
│   ├── feature_service.py
│   └── execution/       # Executor pattern
│       ├── base_executor.py
│       ├── executor_factory.py
│       └── executors/
└── models/              # Database models (if needed)
```

### Pydantic Models
```python
# Follow existing model patterns
class RequestModel(BaseModel):
    field: str = Field(..., description="Field description")
    optional_field: Optional[str] = Field(None, description="Optional field")
    
    class Config:
        schema_extra = {
            "example": {
                "field": "example_value",
                "optional_field": "optional_example"
            }
        }

class ResponseModel(BaseModel):
    success: bool = Field(..., description="Operation success status")
    message: str = Field(..., description="Status message")
    data: Optional[Dict[str, Any]] = Field(None, description="Response data")
```

### Service Pattern
```python
# Follow existing service patterns
class CustomService:
    """Service for handling custom business logic"""
    
    def __init__(self):
        self.data_store = {}
    
    async def process_request(self, request: RequestModel) -> ResponseModel:
        """Process a custom request with error handling"""
        try:
            # Early validation
            if not request.field:
                raise ValueError("Field is required")
            
            # Business logic here
            result = await self._perform_operation(request)
            
            return ResponseModel(
                success=True,
                message="Operation completed successfully",
                data=result
            )
            
        except Exception as e:
            # Consistent error handling
            return ResponseModel(
                success=False,
                message=f"Operation failed: {str(e)}"
            )
    
    async def _perform_operation(self, request: RequestModel) -> Dict[str, Any]:
        """Private method for core operation logic"""
        # Implementation here
        pass

# Global service instance
custom_service = CustomService()
```

### API Routes
```python
# Follow existing route patterns
from fastapi import APIRouter, HTTPException, Depends
from ..models import RequestModel, ResponseModel
from ..services.custom_service import custom_service

router = APIRouter(tags=["Custom"])

@router.post("/custom", response_model=ResponseModel)
async def custom_endpoint(request: RequestModel):
    """
    Custom endpoint with proper documentation
    """
    try:
        result = await custom_service.process_request(request)
        return result
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

## Naming Conventions

### Frontend
- Components: PascalCase (`ApiKeysTab`, `MetricsPanel`)
- Files: PascalCase for components (`ApiNode.tsx`)
- Directories: kebab-case (`components/api-keys`)
- Hooks: camelCase with "use" prefix (`useApiKeys`)
- Contexts: PascalCase with "Context" suffix (`ApiKeysContext`)

### Backend
- Files: snake_case (`api_keys_service.py`)
- Classes: PascalCase (`ApiKeyService`)
- Functions/methods: snake_case (`get_api_key`)
- Models: PascalCase (`ApiKeyResponse`)
- Enums: PascalCase with descriptive values (`ApiProviderType.OPENAI`)

## AI Integration Patterns

### Follow existing AI service patterns
- Use provider-specific implementations with common interface
- Implement usage tracking and cost calculation
- Handle API key management through dedicated service
- Use proper async/await patterns for external API calls

### Executor Pattern
- Extend `BaseExecutor` for new execution types
- Use `ExecutorFactory` for dynamic executor creation
- Implement proper error handling and status tracking
- Support both sync and async execution modes

## Performance & Security

### Frontend
- Use React.memo for expensive components
- Implement proper loading states with Suspense
- Use TanStack Query for server state caching
- Sanitize user inputs with Zod validation

### Backend
- Use async/await for all I/O operations
- Implement proper connection pooling for Neo4j
- Use SecretStr for sensitive data in Pydantic models
- Implement rate limiting for API endpoints

## Testing Patterns

### Frontend
- Test components with React Testing Library
- Mock services and contexts for isolated testing
- Test user interactions and form submissions

### Backend
- Use pytest with async support
- Mock external API calls (AI providers, databases)
- Test service methods independently from routes
- Use factory patterns for test data creation

## Documentation

### Code Comments
- Use docstrings for all public functions/classes
- Include parameter descriptions and return types
- Provide usage examples for complex functions
- Document business logic and domain-specific concepts

### API Documentation
- Use FastAPI automatic OpenAPI generation
- Provide clear descriptions for all endpoints
- Include request/response examples
- Document error scenarios and status codes

Remember to maintain consistency with existing patterns and gradually refactor legacy code to match these standards. 